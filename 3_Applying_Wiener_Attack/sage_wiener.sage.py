

# This file was *autogenerated* from the file sage_wiener.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_2048 = Integer(2048)###############################################################################
# Fichier : sage_wiener.sage
###############################################################################

from sage.all import (
    Integer,       
    sqrt,          
    RealField,      
)
import re

def wiener_attack(N, e):
    """
    Version "classique" de l'attaque de Wiener, développant e/N (fraction continue)
    Borne d < N^0.25.
    """
    N = Integer(N)
    e = Integer(e)

    
    cf = (e / N).continued_fraction()
    
    convergents = cf.convergents()

    for frac in convergents:
        k = frac.numerator()
        d = frac.denominator()
        if k == _sage_const_0 :
            continue
       
        if (e * d - _sage_const_1 ) % k != _sage_const_0 :
            continue
        phi = (e * d - _sage_const_1 ) // k
        if phi < _sage_const_0 :
            continue
        
        s = N - phi + _sage_const_1 
        discriminant = s * s - _sage_const_4  * N
        if discriminant >= _sage_const_0 :
            sqrt_disc = Integer(discriminant).isqrt()
            if sqrt_disc * sqrt_disc == discriminant:
                p = (s + sqrt_disc) // _sage_const_2 
                q = (s - sqrt_disc) // _sage_const_2 
                if p * q == N:
                    return (p, q, d)
    return None


def deweger_attack(N, e, precision_bits=_sage_const_2048 ):
    """
    Implémentation de l’attaque de de Weger.
    N, e : entiers RSA
    precision_bits : nb de bits de précision pour le calcul de sqrt(N).
    """

   
    N = Integer(N)
    e = Integer(e)


    R = RealField(precision_bits)

    # Construire alpha  en version "réelle"
    alpha = R(e) / (R(N) + R(_sage_const_1 ) - _sage_const_2  * R(N).sqrt())

    r_approx = alpha.exact_rational()
 
    cf = r_approx.continued_fraction()


    # copy paste of wiener
    for frac in cf.convergents():
        # vu que k et d peuvent être "rationnels" -> on cast en Integer
        k = Integer(frac.numerator())
        d = Integer(frac.denominator())

        if k == _sage_const_0 :
            continue

        
        if (e * d - _sage_const_1 ) % k != _sage_const_0 :
            continue

        
        phi_candidate = (e * d - _sage_const_1 ) // k
        if phi_candidate < _sage_const_0 :
            continue

        
        # check
        s = N - phi_candidate + _sage_const_1 
        disc = s * s - _sage_const_4  * N

        if disc < _sage_const_0 :
            continue

        sqrt_disc = Integer(disc).isqrt()
        if sqrt_disc * sqrt_disc == disc:
            p = (s + sqrt_disc) // _sage_const_2 
            q = (s - sqrt_disc) // _sage_const_2 
            if p * q == N:
                return (p, q, d)

    return None


def read_file(filename):
    with open(filename, "r") as f:
        content = f.read()
    return content


def parse_input(data):
    """
    Exemple de parsing: on recherche des lignes du type:
      N1=1234
      e1=5678
      N2=...
      e2=...
    Renvoie une liste de tuples (N, e).
    """
    pairs = re.findall(r"N(\d+)=(\d+)\s+e(\d+)=(\d+)", data)
    # pairs est une liste de tuples ( '1','1234','1','5678' ), etc.
    # On ne garde que (N, e) convertis en int
    return [(int(n), int(e)) for _, n, _, e in pairs]


def main():
    input_file = "integers_to_factorize2.txt"
    data = read_file(input_file)
    parsed_data = parse_input(data)
    
    for i, (N, e) in enumerate(parsed_data, start=_sage_const_1 ):
        
        result = deweger_attack(N, e, precision_bits=_sage_const_2 *N.bit_length())
       

        if result is not None:
            p, q, d = result
            print(f"[Case {i}] Found factors p = {p}, q = {q}, and private key d = {d}")
        else:
            print(f"[Case {i}] de Weger attack failed to find factors.")


if __name__ == "__main__":
    main()

